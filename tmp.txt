    modules.sort(key=lambda m: m.base_address)
    return modules


def describe_address(address: int, modules: Sequence[ModuleInfo]) -> str:
    """Return module+offset notation if possible."""
    for module in modules:
        if module.base_address <= address < module.base_address + module.size:
            offset = address - module.base_address
            base_name = os.path.basename(module.path) or module.path
            return f"{base_name}+0x{offset:X}"
    return f"0x{address:X}"


def read_regions(context: ScanContext) -> List[Region]:
    """Enumerate readable and committed memory regions."""
    if context.mock:
        return context.mock_regions

    if not IS_WINDOWS or ctypes is None:
        raise RuntimeError("Memory enumeration requires Windows.")

    class MEMORY_BASIC_INFORMATION(ctypes.Structure):  # type: ignore
        _fields_ = [
            ("BaseAddress", ctypes.c_void_p),
            ("AllocationBase", ctypes.c_void_p),
            ("AllocationProtect", wintypes.DWORD),
            ("RegionSize", ctypes.c_size_t),
            ("State", wintypes.DWORD),
            ("Protect", wintypes.DWORD),
            ("Type", wintypes.DWORD),
        ]

    kernel32 = ctypes.windll.kernel32
    regions: List[Region] = []
    addr = 0
    mbi = MEMORY_BASIC_INFORMATION()
    while kernel32.VirtualQueryEx(
        context.handle, ctypes.c_void_p(addr), ctypes.byref(mbi), ctypes.sizeof(mbi)
    ):
        base = mbi.BaseAddress
        size = mbi.RegionSize
        state = mbi.State
        protect = mbi.Protect
        readable = (protect & PAGE_GUARD) == 0 and (protect in READABLE_PROTECTIONS)
        if state == MEM_COMMIT and readable and size:
            regions.append(Region(base, size, protect, state, mbi.Type))
        addr = base + size
        if addr > (1 << (context.pointer_size * 8)) - 1:
            break
    return regions


def read_process_memory(context: ScanContext, address: int, size: int) -> bytes:
    """Read raw bytes from the target process or mock memory."""
    if context.mock:
        for region in context.mock_regions:
            if region.base_address <= address < region.base_address + region.size:
                offset = address - region.base_address
                block = context.mock_data[region.base_address]
                return block[offset : offset + size]
        raise ValueError(f"Mock address 0x{address:X} outside generated regions.")

    if not IS_WINDOWS or ctypes is None or not context.handle:
        raise RuntimeError("Process reading requires Windows and a valid handle.")
    buffer = (ctypes.c_ubyte * size)()
    bytes_read = ctypes.c_size_t(0)
    success = ctypes.windll.kernel32.ReadProcessMemory(
        context.handle,
        ctypes.c_void_p(address),
        ctypes.byref(buffer),
        size,
        ctypes.byref(bytes_read),
    )
    if not success:
        raise OSError(f"Could not read memory at 0x{address:X}")
    return bytes(buffer[: bytes_read.value])


# ----- Value search --------------------------------------------------------
